<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Calculadora 3D Avanzada</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- React & ReactDOM CDN -->
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <!-- Babel para JSX en el navegador -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <!-- Three.js CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Google Fonts: Caveat (Handwritten) -->
    <link href="https://fonts.googleapis.com/css2?family=Caveat:wght@400..700&display=swap" rel="stylesheet">
    <style>
        .handwritten { 
            font-family: 'Caveat', cursive; 
            font-variant-numeric: tabular-nums; 
        }
        
        .blackboard-steps {
            background-color: #0f0f0f;
            border: 12px solid #2a1a15;
            border-radius: 8px;
            box-shadow: inset 0 0 40px rgba(0,0,0,1), 8px 10px 25px rgba(0,0,0,0.8);
            background-image: url("data:image/svg+xml,%3Csvg width='100' height='100' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.8' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100' height='100' filter='url(%23n)' opacity='0.08'/%3E%3C/svg%3E");
        }

        .worn-brown-3d {
            background-color: #6d4c41;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='200' height='200'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.8' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23n)' opacity='0.3'/%3E%3C/svg%3E");
            border-radius: 20px;
            box-shadow: inset -8px -8px 20px rgba(0,0,0,0.7), inset 8px 8px 20px rgba(255,255,255,0.1), 15px 25px 35px rgba(0,0,0,0.9), 0px 0px 0px 10px #3e2723, inset 0px 0px 0px 3px #21110b;
            border-top: 5px solid #8d6e63; 
            border-left: 5px solid #8d6e63; 
            border-bottom: 5px solid #2a1a15; 
            border-right: 5px solid #2a1a15;
        }

        .screen-3d {
            background-color: #929a7c;
            box-shadow: inset 6px 6px 15px rgba(0,0,0,0.7), inset -2px -2px 8px rgba(255,255,255,0.3), 0 0 0 5px #2b1b17;
            border: 4px solid #1a100b; 
            border-bottom-color: #6d4c41; 
            border-right-color: #6d4c41;
            color: #1a1a1a; 
            text-shadow: 1px 1px 0px rgba(255,255,255,0.2); 
            font-family: 'Courier New', monospace;
        }

        .calc-btn {
            background-color: #5d4037; 
            background-image: linear-gradient(135deg, #795548 0%, #3e2723 100%);
            color: #d7ccc8; 
            border-radius: 10px; 
            border: 3px solid #a1887f; 
            border-bottom-width: 4px; 
            border-right-width: 4px; 
            border-bottom-color: #1a100b; 
            border-right-color: #1a100b;
            box-shadow: 3px 5px 8px rgba(0,0,0,0.7); 
            transition: all 0.1s; 
            font-family: 'Courier New', monospace; 
            font-size: 1.4rem; 
            font-weight: bold;
            display: flex; 
            align-items: center; 
            justify-content: center; 
            height: 60px; 
            text-shadow: 1px 1px 3px #000; 
            cursor: pointer;
            user-select: none;
        }

        .calc-btn:active { 
            transform: translateY(4px) translateX(2px); 
            box-shadow: 0px 1px 2px rgba(0,0,0,0.8); 
            border: 3px solid #3e2723; 
            border-bottom-color: #a1887f; 
            border-right-color: #a1887f; 
        }

        .op-btn { 
            background-image: linear-gradient(135deg, #8d6e63 0%, #4e342e 100%); 
            color: #ffb74d; 
        }

        .special-btn { 
            background-image: linear-gradient(135deg, #fbc02d 0%, #f9a825 100%); 
            color: #d32f2f;
            border-top-color: #fff176; 
            border-left-color: #fff176;
            text-shadow: 0.5px 0.5px 1px rgba(255,255,255,0.3);
        }

        .eq-btn { 
            background-image: linear-gradient(135deg, #e65100 0%, #bf360c 100%); 
            color: #fff; 
            border-top-color: #ff9800; 
            border-left-color: #ff9800; 
        }

        .clear-btn { 
            background-image: linear-gradient(135deg, #c62828 0%, #8e0000 100%); 
            border-top-color: #ef5350; 
            border-left-color: #ef5350; 
            color: white; 
        }

        .step-animation { 
            animation: slideIn 0.3s ease-out forwards; 
            opacity: 0; 
            transform: translateY(10px); 
        }

        @keyframes slideIn { 
            to { opacity: 1; transform: translateY(0); } 
        }
        @keyframes fadeIn { 
            from { opacity: 0; transform: scale(0.8); } 
            to { opacity: 1; transform: scale(1); } 
        }

        /* Canvas container styles */
        #three-canvas-container {
            width: 100%;
            height: 450px;
            cursor: move;
        }
    </style>
</head>
<body class="bg-stone-900">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // Visor 3D usando Three.js
        const ThreeDViewer = ({ figure, onBack }) => {
            const mountRef = useRef(null);

            useEffect(() => {
                const currentMount = mountRef.current;
                const width = currentMount.clientWidth;
                const height = currentMount.clientHeight;

                const scene = new THREE.Scene();
                const camera = new THREE.PerspectiveCamera(45, width / height, 0.1, 1000);
                camera.position.z = 7; 

                const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                renderer.setSize(width, height);
                renderer.setClearColor(0x000000, 0);
                currentMount.appendChild(renderer.domElement);

                const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
                scene.add(ambientLight);
                const pointLight = new THREE.PointLight(0xffffff, 1);
                pointLight.position.set(10, 10, 10);
                scene.add(pointLight);

                let geometry;
                switch (figure) {
                    case 'Cubo':
                        geometry = new THREE.BoxGeometry(2.5, 2.5, 2.5);
                        break;
                    case 'Tetraedro':
                        geometry = new THREE.TetrahedronGeometry(2.5);
                        break;
                    case 'Octaedro':
                        geometry = new THREE.OctahedronGeometry(2.5);
                        break;
                    case 'Dodecaedro':
                        geometry = new THREE.DodecahedronGeometry(2.5);
                        break;
                    case 'Icosaedro':
                        geometry = new THREE.IcosahedronGeometry(2.5);
                        break;
                    case 'Prisma':
                        geometry = new THREE.CylinderGeometry(1.8, 1.8, 3.5, 6);
                        break;
                    case 'Pirámide':
                        geometry = new THREE.ConeGeometry(2, 3.5, 4);
                        break;
                    case 'Esfera':
                        geometry = new THREE.SphereGeometry(2, 32, 32);
                        break;
                    case 'Cilindro':
                        geometry = new THREE.CylinderGeometry(1.8, 1.8, 3.5, 32);
                        break;
                    case 'Cono':
                        geometry = new THREE.ConeGeometry(1.8, 3.5, 32);
                        break;
                    default:
                        geometry = new THREE.BoxGeometry(2, 2, 2);
                }

                const material = new THREE.MeshStandardMaterial({ 
                    color: 0xf8f1e0, 
                    transparent: true, 
                    opacity: 0.25,
                    side: THREE.DoubleSide
                });
                const mesh = new THREE.Mesh(geometry, material);
                
                const edges = new THREE.EdgesGeometry(geometry);
                const lineMaterial = new THREE.LineBasicMaterial({ color: 0xffffff, linewidth: 2 });
                const wireframe = new THREE.LineSegments(edges, lineMaterial);
                
                const group = new THREE.Group();
                group.add(mesh);
                group.add(wireframe);
                scene.add(group);

                let isDragging = false;
                let previousMousePosition = { x: 0, y: 0 };

                const onMouseDown = (e) => { isDragging = true; };
                const onMouseUp = (e) => { isDragging = false; };
                const onMouseMove = (e) => {
                    const deltaMove = {
                        x: e.offsetX - previousMousePosition.x,
                        y: e.offsetY - previousMousePosition.y
                    };

                    if (isDragging) {
                        const deltaRotationQuaternion = new THREE.Quaternion()
                            .setFromEuler(new THREE.Euler(
                                (deltaMove.y * Math.PI) / 180,
                                (deltaMove.x * Math.PI) / 180,
                                0,
                                'XYZ'
                            ));
                        group.quaternion.multiplyQuaternions(deltaRotationQuaternion, group.quaternion);
                    }

                    previousMousePosition = { x: e.offsetX, y: e.offsetY };
                };

                const onTouchMove = (e) => {
                    if (e.touches.length > 0) {
                        const touch = e.touches[0];
                        const rect = currentMount.getBoundingClientRect();
                        const x = touch.clientX - rect.left;
                        const y = touch.clientY - rect.top;
                        
                        if (previousMousePosition.x !== 0) {
                            const deltaMove = {
                                x: x - previousMousePosition.x,
                                y: y - previousMousePosition.y
                            };
                            const deltaRotationQuaternion = new THREE.Quaternion()
                                .setFromEuler(new THREE.Euler(
                                    (deltaMove.y * Math.PI) / 180,
                                    (deltaMove.x * Math.PI) / 180,
                                    0,
                                    'XYZ'
                                ));
                            group.quaternion.multiplyQuaternions(deltaRotationQuaternion, group.quaternion);
                        }
                        previousMousePosition = { x, y };
                    }
                };

                currentMount.addEventListener('mousedown', onMouseDown);
                window.addEventListener('mouseup', onMouseUp);
                currentMount.addEventListener('mousemove', onMouseMove);
                currentMount.addEventListener('touchstart', onMouseDown);
                window.addEventListener('touchend', onMouseUp);
                currentMount.addEventListener('touchmove', onTouchMove);

                let animationId;
                const animate = () => {
                    animationId = requestAnimationFrame(animate);
                    if (!isDragging) group.rotation.y += 0.005;
                    renderer.render(scene, camera);
                };
                animate();

                return () => {
                    cancelAnimationFrame(animationId);
                    currentMount.removeEventListener('mousedown', onMouseDown);
                    window.removeEventListener('mouseup', onMouseUp);
                    currentMount.removeEventListener('mousemove', onMouseMove);
                    currentMount.removeEventListener('touchstart', onMouseDown);
                    window.removeEventListener('touchend', onMouseUp);
                    currentMount.removeEventListener('touchmove', onTouchMove);
                    currentMount.removeChild(renderer.domElement);
                };
            }, [figure]);

            return (
                <div className="w-full flex flex-col items-center">
                    <div className="w-full flex justify-between items-center px-4 mb-2">
                        <span className="text-4xl text-[#fbc02d]">{figure}</span>
                        <button 
                            onClick={onBack}
                            className="bg-white/10 hover:bg-white/20 px-4 py-1 rounded text-xl border border-white/30 text-white"
                        >
                            ← Volver
                        </button>
                    </div>
                    <div id="three-canvas-container" ref={mountRef}></div>
                    <p className="text-xl opacity-60 mt-2 text-white">Arrastra para girar la figura</p>
                </div>
            );
        };

        function App() {
            const [input, setInput] = useState('');
            const [steps, setSteps] = useState([]);
            const [showSteps, setShowSteps] = useState(false);
            const [comparisonList, setComparisonList] = useState([]);

            const handleBtn = (val) => {
                if (showSteps) {
                    const currentType = steps[0]?.type;
                    const isComparisonMode = currentType === 'comparison-sequential';
                    const isPartOfFraction = /[0-9./]/.test(val) || val === '/';

                    if (isComparisonMode && (isPartOfFraction || val === 'frac2')) {
                        // Seguir en modo comparación
                    } else if (val !== 'frac1' && val !== 'frac2' && val !== '3D') {
                        setShowSteps(false);
                        setSteps([]);
                        setComparisonList([]);
                        
                        if (['+', '-', '*', '/'].includes(val)) {
                            const lastStep = steps[steps.length - 1];
                            let baseValue = '';
                            if (lastStep) {
                                if (lastStep.type === 'equation') baseValue = lastStep.value;
                                else if (lastStep.res !== undefined) baseValue = lastStep.res.toString();
                            }
                            setInput(baseValue + val);
                            return;
                        }
                        if (!isPartOfFraction && val !== 'C' && val !== '=') setInput('');
                    }
                }

                if (val === 'C') {
                    setInput('');
                    setShowSteps(false);
                    setSteps([]);
                    setComparisonList([]);
                    return;
                }

                if (val === 'frac1') {
                    const normalizedInput = input.replace(/:/g, '/');
                    if (normalizedInput !== '' && !normalizedInput.includes('Escribe')) {
                        setSteps([{ type: 'fraction', value: normalizedInput }]);
                        setShowSteps(true);
                        setComparisonList([]);
                    } else {
                        setInput('Escribe una fracción.');
                        setShowSteps(false);
                    }
                    return;
                }

                if (val === 'frac2') {
                    const normalizedInput = input.replace(/:/g, '/');
                    const isFraction = /\d+[\/]\d+/.test(normalizedInput);

                    if (isFraction) {
                        if (comparisonList.length < 2) {
                            const newList = [...comparisonList, normalizedInput];
                            setComparisonList(newList);
                            setSteps([{ type: 'comparison-sequential', value: newList }]);
                            setShowSteps(true);
                            setInput(''); 
                        }
                    } else {
                        // Si no hay fracción escrita o ya estamos en un mensaje, ponemos el mensaje solicitado
                        setInput('Escribe 2 fracciones');
                        setShowSteps(false);
                        setComparisonList([]);
                        setSteps([]);
                    }
                    return;
                }

                if (val === '3D') {
                    setSteps([{ type: 'geometry-list' }]);
                    setShowSteps(true);
                    setComparisonList([]);
                    setInput('');
                    return;
                }

                if (input.includes('Escribe')) {
                    if (val === '=') return;
                    if (['+', '*', '/'].includes(val)) return;
                    setInput(val);
                    return;
                }

                if (val === '=') {
                    if (!input) return;
                    const calculatedSteps = resolveSteps(input);
                    setSteps(calculatedSteps);
                    setShowSteps(true);
                    setComparisonList([]);
                    return;
                }

                if (input === '' && ['+', '*', '/'].includes(val)) return;

                const lastChar = input.slice(-1);
                if (['+', '-', '*', '/'].includes(val) && ['+', '-', '*', '/'].includes(lastChar)) {
                    setInput(input.slice(0, -1) + val);
                    return;
                }

                setInput((prev) => prev + val);
            };

            const alignDecimals = (a, b) => {
                let strA = String(a), strB = String(b);
                let decA = strA.includes('.') ? strA.split('.')[1].length : 0;
                let decB = strB.includes('.') ? strB.split('.')[1].length : 0;
                let maxDec = Math.max(decA, decB);
                if (maxDec > 0) return { a: parseFloat(a).toFixed(maxDec), b: parseFloat(b).toFixed(maxDec) };
                return { a: strA, b: strB };
            };

            const getMulSteps = (a, b) => {
                const absA = Math.abs(parseFloat(a));
                const strB = String(Math.abs(parseFloat(b))).replace('.', '');
                const partials = [];
                for (let i = strB.length - 1; i >= 0; i--) partials.push(absA * parseInt(strB[i], 10));
                return { a, b, partials };
            };

            const getDivSteps = (a, b) => {
                let intA = Math.abs(parseFloat(a)), intB = Math.abs(parseFloat(b));
                if (intB === 0) return { dividend: intA, divisor: intB, quotient: "Error", steps: [] };
                let divStr = String(intA), steps = [], quotient = "", currentStr = "";
                for (let i = 0; i < divStr.length; i++) {
                    currentStr += divStr[i];
                    let num = parseInt(currentStr, 10);
                    if (num >= intB || (i === divStr.length - 1 && quotient.length > 0)) {
                        let q = Math.floor(num / intB);
                        quotient += q;
                        let sub = q * intB;
                        let rem = num - sub;
                        steps.push({ current: num, currentStr: currentStr, sub: sub, rem: rem, pad: divStr.length - 1 - i });
                        currentStr = String(rem);
                    } else if (quotient.length > 0) quotient += "0";
                }
                return { dividend: intA, divisor: intB, quotient: quotient || "0", steps };
            };

            const resolveSteps = (expression) => {
                let current = expression.replace(/\s+/g, '').replace(/:/g, '/');
                const stepsArray = [{ type: 'equation', value: current }];
                const evalMath = (a, op, b) => {
                    a = parseFloat(a); b = parseFloat(b);
                    if (op === '*') return a * b; if (op === '/') return a / b;
                    if (op === '+') return a + b; if (op === '-') return a - b;
                    return 0;
                };
                const getOpDetails = (a, op, b) => {
                    if (op === '+') return alignDecimals(a, b);
                    if (op === '-') return alignDecimals(a, b);
                    if (op === '*') return getMulSteps(a, b);
                    if (op === '/') return getDivSteps(a, b);
                };
                const reMulDiv = /(-?\d+(?:\.\d+)?)([\*\/])(-?\d+(?:\.\d+)?)/;
                const reAddSub = /(-?\d+(?:\.\d+)?)([\+\-])(\d+(?:\.\d+)?)/;
                try {
                    let iterations = 0;
                    while (iterations < 10) {
                        let match = current.match(reMulDiv) || current.match(reAddSub);
                        if (!match) break;
                        let res = evalMath(match[1], match[2], match[3]);
                        stepsArray.push({ 
                            type: 'operation', 
                            op: match[2], 
                            a: match[1] || "0", 
                            b: match[3], 
                            res: res, 
                            details: getOpDetails(match[1] || "0", match[2], match[3]) 
                        });
                        current = current.replace(match[0], res.toString());
                        stepsArray.push({ type: 'equation', value: current });
                        iterations++;
                    }
                } catch (e) { return [{ type: 'equation', value: "Error" }]; }
                return stepsArray;
            };

            const renderSingleFraction = (fStr, size = "large") => {
                const parts = fStr.split('/');
                const n = parseInt(parts[0], 10) || 0, d = parseInt(parts[1], 10) || 1;
                const units = [];
                const totalUnits = Math.ceil(n / d);
                for (let i = 0; i < totalUnits; i++) units.push({ total: d, filled: Math.min(d, n - (i * d)) });
                
                const isLarge = size === "large";
                
                const pieClass = isLarge ? "w-44 h-44 md:w-60 md:h-60" : "w-24 h-24 md:w-36 md:h-36";
                const barWidth = isLarge ? "w-48 md:w-72" : "w-28 md:w-44";
                const barHeight = isLarge ? "h-14 md:h-20" : "h-10 md:h-12";
                
                const textScale = isLarge ? "scale-[2]" : "scale-[1.4]";

                return (
                    <div className="flex flex-col items-center gap-8">
                        <div className={`flex flex-col items-center gap-0 ${textScale} origin-top transform-gpu`}>
                            <div className="tracking-widest font-bold leading-tight text-white">{n}</div>
                            <div className="border-t-4 border-white w-full min-w-[2.5rem]"></div>
                            <div className="tracking-widest font-bold leading-tight text-white">{d}</div>
                        </div>

                        <div className={`flex flex-col items-center ${isLarge ? 'gap-12' : 'gap-8'}`}>
                            <div className="flex flex-wrap justify-center gap-6">
                                {units.map((u, i) => (
                                    <svg key={i} viewBox="0 0 100 100" className={`${pieClass} drop-shadow-lg`}>
                                        {[...Array(u.total)].map((_, j) => {
                                            const s = (j / u.total) * 2 * Math.PI - Math.PI / 2;
                                            const e = ((j + 1) / u.total) * 2 * Math.PI - Math.PI / 2;
                                            const x1 = 50 + 40 * Math.cos(s), y1 = 50 + 40 * Math.sin(s);
                                            const x2 = 50 + 40 * Math.cos(e), y2 = 50 + 40 * Math.sin(e);
                                            const largeArc = (e - s) > Math.PI ? 1 : 0;
                                            const dPath = u.total === 1 ? "M 50 10 A 40 40 0 1 1 50 90 A 40 40 0 1 1 50 10" : `M 50 50 L ${x1} ${y1} A 40 40 0 ${largeArc} 1 ${x2} ${y2} Z`;
                                            return <path key={j} d={dPath} fill={j < u.filled ? "#f8f1e0" : "transparent"} stroke="white" strokeWidth="2.5" />;
                                        })}
                                    </svg>
                                ))}
                            </div>
                            <div className="flex flex-wrap justify-center gap-6">
                                {units.map((u, i) => (
                                    <div key={i} className={`flex border-[5px] border-white ${barWidth} ${barHeight} overflow-hidden shadow-md bg-white/5`}>
                                        {[...Array(u.total)].map((_, k) => <div key={k} className={`flex-1 border-r-4 last:border-r-0 border-white/40 ${k < u.filled ? 'bg-[#f8f1e0] opacity-90' : ''}`} />)}
                                    </div>
                                ))}
                            </div>
                        </div>
                    </div>
                );
            };

            const renderVerticalMath = (step) => {
                const { op, details, res } = step;
                if (op === '+' || op === '-') {
                    return (
                        <div className="flex flex-col items-end handwritten text-4xl md:text-5xl leading-none text-white w-fit pl-10 mb-8 mt-4">
                            <div className="tracking-widest">{details.a}</div>
                            <div className="border-b-4 border-white pb-2 mb-2 flex justify-between w-full min-w-[8rem] gap-10">
                                <span>{op}</span>
                                <span className="tracking-widest">{details.b}</span>
                            </div>
                            <div className="tracking-widest font-bold text-[#f8f1e0]">{res}</div>
                        </div>
                    );
                }
                if (op === '*') {
                    return (
                        <div className="flex flex-col items-end handwritten text-4xl md:text-5xl leading-none text-white w-fit pl-10 mb-8 mt-4">
                            <div className="tracking-widest">{details.a}</div>
                            <div className="border-b-4 border-white pb-2 mb-2 flex justify-between w-full min-w-[8rem] gap-10">
                                <span>×</span>
                                <span className="tracking-widest">{details.b}</span>
                            </div>
                            {details.partials && details.partials.length > 1 ? (
                                <>
                                    {details.partials.map((p, i) => (
                                        <div key={i} className="tracking-widest" style={{ paddingRight: `${i}ch` }}>{p}</div>
                                    ))}
                                    <div className="border-t-2 border-white/40 w-full mt-2 pt-2 text-right tracking-widest font-bold text-[#f8f1e0]">{res}</div>
                                </>
                            ) : <div className="tracking-widest font-bold text-[#f8f1e0]">{res}</div>}
                        </div>
                    );
                }
                if (op === '/') {
                    const { dividend, divisor, quotient, steps } = details;
                    const divStr = String(dividend);
                    const arcLen = steps.length > 0 ? String(steps[0].currentStr).length : 1;
                    return (
                        <div className="flex handwritten text-4xl md:text-5xl leading-none text-white gap-16 w-fit pl-4 mb-8 mt-6">
                            <div className="flex flex-col items-start pt-2">
                                <div className="flex relative">
                                    <svg className="absolute w-[calc(100%-0.1em)] h-4 -top-4 left-0 text-white" preserveAspectRatio="none" viewBox="0 0 100 100">
                                        <path d="M 5,100 Q 50,-40 95,100" stroke="currentColor" strokeWidth="15" fill="none" />
                                    </svg>
                                    <span className="tracking-widest">{divStr.substring(0, arcLen)}</span>
                                    <span className="tracking-widest opacity-80">{divStr.substring(arcLen)}</span>
                                </div>
                                {steps.map((s, idx) => {
                                    if (idx === 0) return null;
                                    const leftMargin = divStr.length - s.pad - String(s.currentStr).length;
                                    return <div key={idx} className="tracking-widest text-white" style={{ marginLeft: `${Math.max(0, leftMargin)}ch` }}>{s.currentStr}</div>;
                                })}
                                {steps.length > 0 && (() => {
                                    const last = steps[steps.length - 1];
                                    const remStr = String(last.rem);
                                    const leftMargin = divStr.length - last.pad - remStr.length;
                                    return (
                                        <div className="relative inline-block mt-2" style={{ marginLeft: `${Math.max(0, leftMargin)}ch` }}>
                                            <span className="tracking-widest font-bold text-[#f8f1e0]">{remStr}</span>
                                            <svg className="absolute -bottom-4 left-0 w-full h-4 text-[#f8f1e0]/60" preserveAspectRatio="none" viewBox="0 0 100 100">
                                                <path d="M 0,0 Q 50,100 100,0" stroke="currentColor" strokeWidth="12" fill="none" strokeLinecap="round" />
                                            </svg>
                                        </div>
                                    );
                                })()}
                            </div>
                            <div className="flex flex-col items-start">
                                <div className="border-l-4 border-b-4 border-white pl-6 pb-4 tracking-widest min-w-[7rem]">{divisor}</div>
                                <div className="pl-6 pt-4 tracking-widest font-bold text-[#f8f1e0]">{quotient}</div>
                            </div>
                        </div>
                    );
                }
                return null;
            };

            const renderGeometryList = () => (
                <div className="handwritten text-white w-full flex flex-col gap-4 mt-0 pt-0 animate-[fadeIn_0.4s_ease-out]">
                    <ul className="text-2xl md:text-3xl space-y-3 list-none pl-2">
                        {[
                            { name: 'Cubo', desc: '6 caras cuadradas.' },
                            { name: 'Tetraedro', desc: '4 caras triangulares.' },
                            { name: 'Octaedro', desc: '8 caras triangulares.' },
                            { name: 'Dodecaedro', desc: '12 caras pentagonales.' },
                            { name: 'Icosaedro', desc: '20 caras triangulares.' },
                            { name: 'Prisma', desc: 'Dos bases iguales y caras laterales rectangulares.' },
                            { name: 'Pirámide', desc: 'Base poligonal y caras laterales que se unen en un vértice.' },
                            { name: 'Esfera', desc: 'Superficie curva cuyos puntos están a igual distancia del centro.' },
                            { name: 'Cilindro', desc: 'Dos bases circulares unidas por una superficie lateral curva.' },
                            { name: 'Cono', desc: 'Una base circular que se estrecha hasta un vértice.' }
                        ].map((fig, i) => (
                            <li key={i} className="group cursor-pointer hover:translate-x-2 transition-transform" onClick={() => setSteps([{ type: 'view-3d', figure: fig.name }])}>
                                <span className="text-[#fbc02d] font-bold group-hover:underline">{fig.name}:</span> {fig.desc}
                            </li>
                        ))}
                    </ul>
                </div>
            );

            const renderFractionDisplay = (val, type) => {
                if (type === 'fraction') return <div className="handwritten text-white w-full flex justify-center mt-2">{renderSingleFraction(val)}</div>;
                if (type === 'comparison-sequential') {
                    const list = val, isComplete = list.length === 2;
                    let sym = "?";
                    if (isComplete) {
                        const v1 = parseFloat(list[0].split('/')[0])/parseFloat(list[0].split('/')[1]);
                        const v2 = parseFloat(list[1].split('/')[0])/parseFloat(list[1].split('/')[1]);
                        sym = v1 > v2 ? ">" : v1 < v2 ? "<" : "=";
                    }
                    return (
                        <div className="handwritten text-white w-full flex flex-col items-center gap-4 mt-0">
                            <div className="flex flex-row items-start justify-center gap-4 md:gap-12 w-full pt-2">
                                {list[0] && (
                                    <div className="flex-1 flex justify-center">
                                        {renderSingleFraction(list[0], isComplete ? "small" : "large")}
                                    </div>
                                )}
                                
                                {isComplete && (
                                    <div className="text-7xl md:text-9xl self-center font-bold text-[#f8f1e0] drop-shadow-md px-2 animate-[fadeIn_0.3s]">
                                        {sym}
                                    </div>
                                )}
                                
                                {list[1] && (
                                    <div className="flex-1 flex justify-center">
                                        {renderSingleFraction(list[1], "small")}
                                    </div>
                                )}
                            </div>
                            {list.length < 2 && <div className="text-2xl opacity-50 animate-pulse mt-8 bg-white/10 px-6 py-2 rounded-full text-white">[Escribe la 2ª fracción y pulsa frac2]</div>}
                        </div>
                    );
                }
                return null;
            };

            const formatMathStr = (str) => str.replace(/\*/g, ' × ').replace(/\//g, ' : ').replace(/\+/g, ' + ').replace(/(?!^)\-/g, ' - ');

            return (
                <div className="min-h-screen bg-stone-900 flex flex-col md:flex-row items-center md:items-stretch justify-center p-4 md:p-8 md:pt-16 gap-10 font-sans">
                    <div className="worn-brown-3d p-6 w-full max-w-md flex flex-col gap-6 relative z-10 shrink-0 h-fit">
                        <div className={`screen-3d p-4 rounded-lg flex items-center min-h-[5rem] overflow-x-auto whitespace-nowrap tracking-widest ${input.includes('Escribe') ? 'justify-start' : 'justify-end'}`}>
                            {input.includes('Escribe') ? (
                                <span className="handwritten text-4xl transform scale-[0.85] origin-left inline-block">{input}</span>
                            ) : (
                                <span className="text-4xl font-bold">{input ? input.replace(/\//g, ':') : "0"}</span>
                            )}
                        </div>
                        <div className="grid grid-cols-5 gap-3">
                            {['7', '8', '9', '/', 'frac1'].map(btn => (
                                <button key={btn} onClick={() => handleBtn(btn)} className={`calc-btn ${btn === '/' ? 'op-btn' : btn === 'frac1' ? 'special-btn' : ''}`}>
                                    {btn === 'frac1' ? <span className="text-[10px] transform scale-[2] -rotate-45 origin-center inline-block tracking-tighter">frac1</span> : (btn === '/' ? ':' : btn)}
                                </button>
                            ))}
                            {['4', '5', '6', '*', 'frac2'].map(btn => (
                                <button key={btn} onClick={() => handleBtn(btn)} className={`calc-btn ${btn === '*' ? 'op-btn' : btn === 'frac2' ? 'special-btn' : ''}`}>
                                    {btn === 'frac2' ? <span className="text-[10px] transform scale-[2] -rotate-45 origin-center inline-block tracking-tighter">frac2</span> : (btn === '*' ? '×' : btn)}
                                </button>
                            ))}
                            {['1', '2', '3', '-', '+'].map(btn => (
                                <button key={btn} onClick={() => handleBtn(btn)} className={`calc-btn ${['-', '+'].includes(btn) ? 'op-btn' : ''}`}>{btn}</button>
                            ))}
                            {['0', '.', 'C', '=', '3D'].map(btn => (
                                <button key={btn} onClick={() => handleBtn(btn)} className={`calc-btn ${btn === '=' ? 'eq-btn' : btn === 'C' ? 'clear-btn' : btn === '3D' ? 'special-btn' : ''}`}>
                                    {btn === '3D' ? <span className="text-[10px] transform scale-[2] -rotate-45 origin-center inline-block tracking-tighter">3D</span> : btn}
                                </button>
                            ))}
                        </div>
                    </div>

                    {showSteps && (
                        <div className="blackboard-steps w-full max-w-3xl p-6 md:p-10 relative animate-[fadeIn_0.5s_ease-out] overflow-y-auto min-h-[500px]">
                            <div className="flex flex-col gap-6 text-white w-full h-full items-start justify-start">
                                {steps.map((step, idx) => {
                                    if (step.type === 'equation') {
                                        const isLast = idx === steps.length - 1;
                                        return <div key={idx} className={`handwritten text-left transition-all w-full ${isLast ? 'text-5xl md:text-6xl border-t-2 border-white/20 pt-6 mt-4' : 'text-3xl text-white/30 mb-0'}`}>{formatMathStr(step.value)}</div>;
                                    } else if (step.type === 'operation') {
                                        return <div key={idx} className="step-animation w-full flex justify-start">{renderVerticalMath(step)}</div>;
                                    } else if (step.type === 'fraction' || step.type === 'comparison-sequential') {
                                        return <div key={idx} className="step-animation w-full h-full">{renderFractionDisplay(step.value, step.type)}</div>;
                                    } else if (step.type === 'geometry-list') {
                                        return <div key={idx} className="w-full">{renderGeometryList()}</div>;
                                    } else if (step.type === 'view-3d') {
                                        return <div key={idx} className="w-full h-full"><ThreeDViewer figure={step.figure} onBack={() => setSteps([{type: 'geometry-list'}])} /></div>;
                                    }
                                    return null;
                                })}
                            </div>
                        </div>
                    )}
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>